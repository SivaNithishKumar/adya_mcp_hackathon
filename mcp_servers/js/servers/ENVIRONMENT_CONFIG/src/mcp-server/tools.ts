/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { RequestHandlerExtra } from "@modelcontextprotocol/sdk/shared/protocol.js";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { objectOutputType, ZodRawShape, ZodTypeAny, z } from "zod";
import { CloudinaryEnvConfigCore } from "../core.js";
import { ConsoleLogger } from "./console-logger.js";
import { MCPScope } from "./scopes.js";
import { isAsyncIterable, isBinaryData, valueToBase64 } from "./shared.js";

export type ToolDefinition<Args extends undefined | ZodRawShape = undefined> =
  Args extends ZodRawShape ? {
      name: string;
      description: string;
      scopes?: MCPScope[];
      args: Args;
      tool: (
        client: CloudinaryEnvConfigCore,
        args: objectOutputType<Args, ZodTypeAny>,
        extra: RequestHandlerExtra,
      ) => CallToolResult | Promise<CallToolResult>;
    }
    : {
      name: string;
      description: string;
      scopes?: MCPScope[];
      args?: undefined;
      tool: (
        client: CloudinaryEnvConfigCore,
        extra: RequestHandlerExtra,
      ) => CallToolResult | Promise<CallToolResult>;
    };

// Credential schema for ENVIRONMENT_CONFIG
export const credentialsSchema = z.object({
  cloudName: z.string(),
  apiKey: z.string(),
  apiSecret: z.string(),
});

export type Credentials = z.infer<typeof credentialsSchema>;

// Helper to extract credentials from args or context
function extractCredentials(args: any): Credentials | null {
  if (args && args.__credentials__) {
    const parsed = credentialsSchema.safeParse(args.__credentials__);
    if (parsed.success) return parsed.data;
  }
  return null;
}

// Optional function to assist with formatting tool results
export async function formatResult(
  value: unknown,
  init: { response?: Response | undefined },
): Promise<CallToolResult> {
  if (typeof value === "undefined") {
    return { content: [] };
  }

  const { response } = init;
  const contentType = response?.headers.get("content-type") ?? "";
  let content: CallToolResult["content"] = [];

  if (contentType.search(/\bjson\b/g)) {
    content = [{ type: "text", text: JSON.stringify(value) }];
  } else if (
    contentType.startsWith("text/event-stream")
    && isAsyncIterable(value)
  ) {
    content = await consumeSSE(value);
  } else if (contentType.startsWith("text/") && typeof value === "string") {
    content = [{ type: "text", text: value }];
  } else if (isBinaryData(value) && contentType.startsWith("image/")) {
    const data = await valueToBase64(value);
    content = data == null
      ? []
      : [{ type: "image", data, mimeType: contentType }];
  } else {
    return {
      content: [{
        type: "text",
        text: `Unsupported content type: "${contentType}"`,
      }],
      isError: true,
    };
  }

  return { content };
}

async function consumeSSE(
  value: AsyncIterable<unknown>,
): Promise<CallToolResult["content"]> {
  const content: CallToolResult["content"] = [];

  for await (const chunk of value) {
    if (typeof chunk === "string") {
      content.push({ type: "text", text: chunk });
    } else {
      content.push({ type: "text", text: JSON.stringify(chunk) });
    }
  }

  return content;
}

export function createRegisterTool(
  logger: ConsoleLogger,
  server: McpServer,
  sdk: CloudinaryEnvConfigCore,
  allowedScopes: Set<MCPScope>,
  allowedTools?: Set<string>,
): <A extends ZodRawShape | undefined>(tool: ToolDefinition<A>) => void {
  return <A extends ZodRawShape | undefined>(tool: ToolDefinition<A>): void => {
    if (allowedTools && !allowedTools.has(tool.name)) {
      return;
    }

    const scopes = tool.scopes ?? [];
    if (allowedScopes.size > 0 && scopes.length === 0) {
      return;
    }

    if (
      allowedScopes.size > 0
      && !scopes.every((s: MCPScope) => allowedScopes.has(s))
    ) {
      return;
    }

    if (tool.args) {
      // Add credentials parameter to all tools automatically
      const argsWithCredentials = {
        ...tool.args,
        __credentials__: z.object({
          cloudName: z.string().optional(),
          apiKey: z.string().optional(),
          apiSecret: z.string().optional(),
        }).optional(),
      };
      server.tool(tool.name, tool.description, argsWithCredentials, async (args: any, ctx: RequestHandlerExtra) => {
        // Check for credentials in args and create new client if needed
        let clientToUse = sdk;
        if (args.__credentials__) {
          const { cloudName, apiKey, apiSecret } = args.__credentials__;
          if (apiKey && apiSecret) {
            clientToUse = new CloudinaryEnvConfigCore({
              security: {
                cloudinaryAuth: { apiKey, apiSecret }
              },
              cloudName: cloudName || (sdk as any)._options?.cloudName
            });
          }
        }
        return tool.tool(clientToUse, args, ctx);
      });
    } else {
      server.tool(tool.name, tool.description, async (ctx: RequestHandlerExtra) => {
        return tool.tool(sdk, ctx);
      });
    }

    logger.debug("Registered tool", { name: tool.name });
  };
}
