/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { RequestHandlerExtra } from "@modelcontextprotocol/sdk/shared/protocol.js";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { objectOutputType, ZodRawShape, ZodTypeAny, z } from "zod";
import { CloudinaryAnalysisCore } from "../core.js";
import { ConsoleLogger } from "./console-logger.js";
import { MCPScope } from "./scopes.js";
import { isAsyncIterable, isBinaryData, valueToBase64 } from "./shared.js";

export type ToolDefinition<Args extends undefined | ZodRawShape = undefined> =
  Args extends ZodRawShape ? {
      name: string;
      description: string;
      scopes?: MCPScope[];
      args: Args;
      tool: (
        client: CloudinaryAnalysisCore,
        args: objectOutputType<Args, ZodTypeAny>,
        extra: RequestHandlerExtra,
      ) => CallToolResult | Promise<CallToolResult>;
    }
    : {
      name: string;
      description: string;
      scopes?: MCPScope[];
      args?: undefined;
      tool: (
        client: CloudinaryAnalysisCore,
        extra: RequestHandlerExtra,
      ) => CallToolResult | Promise<CallToolResult>;
    };

// Optional function to assist with formatting tool results
export async function formatResult(
  value: unknown,
  init: { response?: Response | undefined },
): Promise<CallToolResult> {
  if (typeof value === "undefined") {
    return { content: [] };
  }

  const { response } = init;
  const contentType = response?.headers.get("content-type") ?? "";
  let content: CallToolResult["content"] = [];

  if (contentType.search(/\bjson\b/g)) {
    content = [{ type: "text", text: JSON.stringify(value) }];
  } else if (
    contentType.startsWith("text/event-stream")
    && isAsyncIterable(value)
  ) {
    content = await consumeSSE(value);
  } else if (contentType.startsWith("text/") && typeof value === "string") {
    content = [{ type: "text", text: value }];
  } else if (isBinaryData(value) && contentType.startsWith("image/")) {
    const data = await valueToBase64(value);
    content = data == null
      ? []
      : [{ type: "image", data, mimeType: contentType }];
  } else {
    return {
      content: [{
        type: "text",
        text: `Unsupported content type: "${contentType}"`,
      }],
      isError: true,
    };
  }

  return { content };
}

async function consumeSSE(
  value: AsyncIterable<unknown>,
): Promise<CallToolResult["content"]> {
  const content: CallToolResult["content"] = [];

  for await (const chunk of value) {
    if (typeof chunk === "string") {
      content.push({ type: "text", text: chunk });
    } else {
      content.push({ type: "text", text: JSON.stringify(chunk) });
    }
  }

  return content;
}

export function createRegisterTool(
  logger: ConsoleLogger,
  server: McpServer,
  sdk: CloudinaryAnalysisCore,
  allowedScopes: Set<MCPScope>,
  allowedTools?: Set<string>,
): <A extends ZodRawShape | undefined>(tool: ToolDefinition<A>) => void {
  return <A extends ZodRawShape | undefined>(tool: ToolDefinition<A>): void => {
    if (allowedTools && !allowedTools.has(tool.name)) {
      return;
    }

    const scopes = tool.scopes ?? [];
    if (allowedScopes.size > 0 && scopes.length === 0) {
      return;
    }

    if (
      allowedScopes.size > 0
      && !scopes.every((s: MCPScope) => allowedScopes.has(s))
    ) {
      return;
    }

    if (tool.args) {
      // Remove credential parameters from the original schema and add __credentials__
      const originalArgs = { ...tool.args };
      const credentialParams = ['apiKey', 'apiSecret', 'cloudName'];
      
      // Remove credential parameters from the schema
      credentialParams.forEach(param => {
        if (originalArgs[param]) {
          delete originalArgs[param];
        }
      });
      
      // Add __credentials__ parameter
      const argsWithCredentials = {
        ...originalArgs,
        __credentials__: z.object({
          cloudName: z.string().optional(),
          apiKey: z.string().optional(),
          apiSecret: z.string().optional(),
        }).optional(),
      };
      
      server.tool(tool.name, tool.description, argsWithCredentials, async (args, ctx) => {
        // Extract credentials from __credentials__ and add them to args
        let processedArgs: any = { ...args };
        let clientToUse = sdk;
        
        if (args.__credentials__) {
          const { cloudName, apiKey, apiSecret } = args.__credentials__;
          
          // Add individual credential parameters to args for the tool function
          if (apiKey) processedArgs.apiKey = apiKey;
          if (apiSecret) processedArgs.apiSecret = apiSecret;
          if (cloudName) processedArgs.cloudName = cloudName;
          
          // Also create new client if needed
          if (apiKey && apiSecret) {
            clientToUse = new CloudinaryAnalysisCore({
              security: {
                cloudinaryAuth: { apiKey, apiSecret }
              },
              cloudName: cloudName || sdk._options.cloudName
            });
          }
          
          // Remove __credentials__ from processed args to avoid passing it to the tool
          delete processedArgs.__credentials__;
        }
        
        return tool.tool(clientToUse, processedArgs, ctx);
      });
    } else {
      server.tool(tool.name, tool.description, async (ctx) => {
        return tool.tool(sdk, ctx);
      });
    }

    logger.debug("Registered tool", { name: tool.name });
  };
}
